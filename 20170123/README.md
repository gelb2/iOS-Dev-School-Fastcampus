## 20170123

## 오브젝티브씨와 클래스 파일

### 헤더파일   
* 클래스 타입 메소드, 컨스턴트 선언을 담음.   
* 임포트 지시어로 사용.   
* 프레임워크의 경우는 `<framework>`로 사용…프레임워크를 가져오면 해당 프레임워크에 있는 모든 헤더파일을 다 읽어올 수 있음.   
* 다른 클래스의 경우는 클래스파일.h로 헤더파일을 추가 가능함…m파일은 참조 불가.  
* 헤더파일이 임포트 되어야만 다른 클래스의 객체 생성 및 사용이 가능함
* **즉 임포트는 사용하고자 하는 프로퍼티, 메소드를 참조해서 사용하는 것임**
* **A클래스, B클래스가 있을 때, 헤더파일에서 서로 임포트를 할 경우엔 중복임...@class를 선언한 후에 m파일에 임포트 해야함**

> 임포트와 @class     
두 클래스가 서로 임포트 하면 어떻게 되나?    
서로 두개의 파일이 임포트를 하면 순환참조가 되어 한쪽이 무시되는 경우 생김…따라서. 두 파일 양쪽에 임포트를 하면 안됨…따라서 클래스를 사용해야 함

> **A클래스, B클래스가 있을 때, 헤더파일에서 서로 임포트를 할 경우엔 중복임...@class를 선언한 후에 m파일에 임포트 해야함**

### @class의 사용.   
* “해당 클래스의 이름이 존재한다는 것만 알리는” 것…해당 단어가 어떤 클래스의 이름인지 만을 알리는 기능   
* **즉 @class는 해당 클래스의 존재만을 알려줄 뿐, 프로퍼티와 메소드를 사용 못함**
* **실제 사용 위헤선 @implementation 에 `#import` 시켜야 함.**   
* 상속은 무조건 헤더파일을 읽어오게 하는 것임...엠파일은 무조건 은닉을 시켜주는 파일이므로….   
* **즉 헤더파일을 임포트 해오는게 낫냐 아니면 클래스만 적는게 맞냐는 상황에 따라 생각해 봐야 함**
* 파라미터로 사용자 정의 데이터 타입을 받을 때 사용함

### 오브젝티브씨 클래스의 특징    
#### interface “선언부”.   
* 상속관계와 프로토콜 선언.   
* 객체와 통신할 메소드를 선언.   
* 프로퍼티 변수를 선언.   
* 헤더파일 안에서 작성됨…주로 헤더파일에 작성되지만 엠파일에도 카테고리를 통해서 작성 가능.   

#### 인터페이스의 구조.   
##### `@interface 해당 클래스의 이름 : 부모 클래스`   

		@interface Suv : Car`   
		@property NSString *name;    
		(void)booting;

##### implementation    
* 클래스의 메소드를 구현하는 실제 코드가 담겨 있음.   
* 엠파일에 작성됨.   
* 사실 안에서도 전역변수라고 해서 변수를 설정할 수도 있긴 하다….   
* 퀵헬프,자세한 주석도 주로 구현파일에 작성하는 것이 좋다….   
* 헤더파일엔 매우 간략한 주석만…

`@implementation car`    

* “인스턴스 메소드의 구현” : 구현부는 임플리멘테이션 파일에 꼭 작성되어야 함…반대로 헤더파일에 작성되면 안됨…프로퍼티 역시 특정 값이 헤더파일에 작성되면 안됨.   

		(void)booting.   
		{NSLog(dsafadsfasdf);
		}    
		@end    
		(@end는 implementation 부분의 종료를 의미함)

## 객체화   
* alloc 메소드로 객체를 만들고, 그 객체를 초기화를 해왔다…그 이유는?    
* 사실 초기화가 내부적으론 뭔지는 정확하게 파악이 힘들다….메모리의 정리, 데이터 엉킴을 예방하는 것으로 이해해야 함…또한 객체 생성시 바로 특정 값을 주는 것 역시 가능.   
* 객체 생성을 작성하면 각 프로퍼티의 값이 들어갈 메모리 공간이 할당됨…

## 메소드   
* 클래스를 선언함…”상속관계와 프로토콜 선언”.   
* 컴퓨터가 수행할 명령어.   
* 인스턴스에 적용되거나 클래스에 적용되는 행동으로 나뉨.   
* 객체는 보통 객체 자신만 접근 가능한 정보를 포함하는데 메서드는 이 데이터에 접근하고 수정하는 방법을 제공함…”객체와 객체 간의 데이터를 주고받는 통신”…따라서 헤더파일에 메소드를 적어 두어야, 다른 객체가 다른 객체의 헤더파일에 적어둔 메소드를 통해 통신 가능

### 메소드의 구조   
* 메소드 타입 : + - 두 가지.   
* 반환타입…필수로 적는 사항…반환할 게 없다면 void로 적는 식.
* return : 반환 값을 나타냄.   
* 메소드명   
* 매개변수…타입과 이름을 적어줌 == ”파라미터”.   
* 메소드내용`{ }`로 함수의 영역을 표시.   
   
		(NSInteger)doubleNum:(NSInteger)number.     
		= 메소드타입,반환타입,메소드명:매개변수   
		{    
		//행동 :” 입력된 숫자를 2배 해서 반환해준다”.   
		return number *2;    
		}

#### 메소드의 파라미터.   
* 파리미터는 쌍따옴표로 입력부분을 구분.   
* 타입과 변수명을 나눠씀.   
* 타입은 괄호 `()`안에 작성.   
* 파라미터는 여러개를 작성도 가능    
* 매개변수는 해당 함수 안에서만 사용 가능

		(NSInteger) sumNum1:(NSInteger)num1 num2(NSInteger)num2   
                   {
                   return num1 + num2;    
                   //행동 : 입력된 두 숫자를 더해 반환해준다.  
                   }

#### 메소드와 반환값    
* 결과값 반환은 반환타입과 같은 타입만 반환 가능…반환되는 값은 무조건 한 개   
* 반환할 값이 없는 경우엔 void 타입으로 메소드를 작성해야 함…따라서 return 키워드를 쓸 필요 없다….   
* 만일 다른 타입의 메소드인데 반환할 값이 없으면 return nil…”아무것도 없는 nil. 이라는 값을 반환한다”는 의미

> 학점계산기 만들어 보기 실습 후 조언
단순히 파일 하나에 과목값, 학생 이름, 계산 메소드를 다 넣기 보단….   
학생, 과목, 계산기 등을 각각에 파일로 만들어서.   
조금 구조가 복잡해지더라도 파일을 여러개로 만들어서 확장성을 늘릴 수 있도록 고려해. 봐야 한다.   
**“객체지향의 기본 개념임”**

### 메시징   
* 메소드를 불러오고 싶다면 오브젝트를 메시징.   
* 메시지는 대괄호`[]`에 의해 표현.   
* 왼쪽은 메시지 받아야 할 오브젝트, 오른쪽은 보낼 메시지.   

		[object message:param];

* 또한 메소드는 중복사용이 가능.   
		
		car *tico = [car alloc];    
		tico = [tico init];    
		//상단 코드는 하단과 같다    
		Car * tico = [[Car alloc] init];

		(NSString *)myName   
		{ Return @“jee”;    
		}

		(void)printName:(NSString *)name{   
		NSLog(@“제 이름은 %@입니다.”,name);    
		}

#### 초기화메소드   
* 인스턴스 생성시 객체의 초기화값을 정해줄 수 있다.   
* 기본 초기화 메소드(init)은 NSObject에 정의되어 있다.   
* **init 메소드는 오버라이드 할 수 있다.**   
* **따라서 사용자 임의대로 Custom init메소드를 만들 수 있다.**   
* **초기화 함수 Return 값으로 instancetype을 반환해주어야 한다**

##### init 메소드의 오버라이드     
1. m파일
2. init 타이핑
3. 자동완성 찾기
4. ”쉽게 쓰는 법임”    

		(instancetype)init   
		{    
		self = [super init];    
		if (self) {   
		//custom init 내용   
		}  
		return self;    
		}

* 커스텀 init 메소드.   

		(instancetyp)initWithNum:(NSInteger)num  
		{    
		self = [super init];    
		if (self) {   
		//.h파일에 property num이 선언되어 있는 상태임    
		self.num = num;    
		}   
		return self;    
		}

## 클래스메소드와 인스턴스 메소드

### 클래스메소드   
* 인스턴스 속성**(객체의 속성)**에 상관없이 클래스 자체에 필요한 행위를 정의할 때 사용.   
		
> `[[car alloc] init];` 에서 init은 클래스 메소드가 아니다


> `[car alloc]` 을 통해서 나오는 것은 객체이므로…


> init 은 객체에 가하는 메소드임….   

* 사용할때 클래스의 이름 적는다.   

> 개발 시 클래스메소드 속 기능만을 구현하고 싶다면…
> 
> 만일 인스턴스메소드로 기능을. 구현하려고 하면 항상 객체를 만들고  메모리에 할당해서 메소드를 구현해야 함…
> 
> 그러나. 클래스메소드는 그냥 기능을 사용 가능….  
>  
때문에 클래스메소드는 굳이 객체를 만들지 않아도 클래스메소드를 호출해서 원하는 기능을 메인 파일에서 활용 가능.   
만일 인스턴스메소드만 활용하게 되면 상황에 따라선 메모리 낭비, 긴 작업시간 소요됨.   

* 프로퍼티의 사용이 불가함    

### 인스턴스메소드.   
* 인스턴스에서 사용되는 행위…대부분의 메소드가 해당…객체에게 가하는 메소드.
* **self와 프로퍼티 사용이 가능하다**   
		
		(id) instanceMethod;

## 캐스팅   
* “형 변환”     
* 계산은 타입 A 로 하면 안에서 돌아가는 계산, 답도 타입 A가 되어야 함…따라서  NS, CGFloat 등 타입 들을 맞춰줘야 함.   
* 예를들어 4.25같은 실수 타입의 답을 나오게 하려면, 계산할 때는  NSUinteger 가. 아니라  CGFloat으로 통일해야….   
* 잘못 잡힌 타입을 하위의 다른 타입으로 다시 정정…’다운캐스팅’    
* 코드 한 줄에서만 임시로 객체의 형을 바꾸고자 할 때…
* **즉 캐스팅은 필요에 의해 데이터타입을 원하는 타입으로 임시로 변환하는 것임**    
		
		id wing = [[Student alloc] initWithName:@“A”];    
		((Student *)wing).grade = 10;    
		wing 앞 부분이 형변환의 예시

## 도형 제작 실습 시 고려사항   
- 공통되는 인자는?    
- 프로퍼티는 어떻게?    
- 길이, 높이, 지름,    
- 클래스는 어떻게?     
- 각 도형들, 넓이, 직사각형 둘레, 원의 둘레, 부피    
- 클래스1 넓이, 부피, 둘레, 원의 둘레

    
> 계산에 필요한 인자들을 전부 프로퍼티 화 하여 클래스로 만든다    
각 도형 별로 클래스를 만든다    
각 도형 클래스 들은 "프로퍼티 인자 클래스"를 상속받는다    
각 도형 클래스의 헤더,엠파일에는 관련 공식을 일일이 작성한다    
메인 엠파일에는 NSLog를 사용해 각자의 넓이, 부피를 띄우는 식을 만든다    

